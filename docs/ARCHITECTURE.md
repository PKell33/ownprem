# Ownprem - Build Prompt

Sovereign Bitcoin infrastructure platform. Single control plane (foundry) manages app servers running Bitcoin services. Web GUI with unified access to all apps.

## Naming

| Concept | Name | Examples |
|---------|------|----------|
| Project | **ownprem** | |
| Orchestrator | **foundry** | Always one |
| App Server | **server** | `foundry`, `server-1`, `server-2` |
| App | **app** | `bitcoin`, `electrs`, `mempool` |

## Architecture Overview

```
                              User
                                │
                                │ https://foundry.local
                                ▼
┌──────────────────────────────────────────────────────────────────────┐
│                            FOUNDRY                                   │
│                                                                      │
│  ┌────────────────────────────────────────────────────────────────┐ │
│  │                    Reverse Proxy (Caddy)                        │ │
│  │  /              → Foundry UI                                    │ │
│  │  /api/*         → Foundry API                                   │ │
│  │  /apps/mempool/ → server-1:3006                                 │ │
│  │  /apps/rtl/     → server-2:3000                                 │ │
│  └────────────────────────────────────────────────────────────────┘ │
│                                                                      │
│  ┌─────────────────┐           ┌─────────────────┐                  │
│  │  Orchestrator   │           │     Agent       │                  │
│  │                 │◄─────────►│                 │                  │
│  │  - REST API     │    WS     │  - Executor     │                  │
│  │  - WebSocket    │           │  - Reporter     │                  │
│  │  - Database     │           │                 │                  │
│  │  - Secrets      │           └────────┬────────┘                  │
│  │  - Proxy Config │                    │                           │
│  └─────────────────┘              ┌─────┴─────┐                     │
│                                   │  bitcoin  │                     │
│                                   └───────────┘                     │
└──────────────────────────────────────────────────────────────────────┘
         │
         │ WebSocket
         │
    ┌────┴─────────────────────────┐
    │                              │
    ▼                              ▼
┌─────────────────┐        ┌─────────────────┐
│    server-1     │        │    server-2     │
│                 │        │                 │
│  ┌───────────┐  │        │  ┌───────────┐  │
│  │   Agent   │  │        │  │   Agent   │  │
│  └─────┬─────┘  │        │  └─────┬─────┘  │
│        │        │        │        │        │
│  ┌─────┴─────┐  │        │  ┌─────┴─────┐  │
│  │  electrs  │  │        │  │    lnd    │  │
│  │  mempool  │  │        │  │    rtl    │  │
│  └───────────┘  │        │  └───────────┘  │
└─────────────────┘        └─────────────────┘
```

## Core Principles

1. **Foundry is orchestrator** - One per deployment. Holds all config, secrets, state.

2. **Orchestrator always talks to agent** - Even on all-in-one deployments. Same code path everywhere.

3. **Agents are dumb executors** - Receive commands, write files, run scripts, report status. No decision making.

4. **Secrets never leave foundry raw** - Generated by orchestrator, stored encrypted, rendered into config files, pushed to agents.

5. **Single entry point** - Users access foundry URL, reverse proxy routes to all app web UIs.

6. **No Docker** - All apps run as native systemd services for better disk I/O.

## Deployment Modes

### All-in-One

Single machine runs everything:

```
┌─────────────────────────────────────┐
│             foundry                 │
│                                     │
│  ┌─────────────┐  ┌─────────────┐  │
│  │Orchestrator │◄►│    Agent    │  │
│  └─────────────┘  └──────┬──────┘  │
│                          │         │
│                    ┌─────┴─────┐   │
│                    │  bitcoin  │   │
│                    │  mempool  │   │
│                    └───────────┘   │
└─────────────────────────────────────┘
```

### Distributed

Multiple machines:

```
┌───────────────────┐  ┌───────────────────┐  ┌───────────────────┐
│      foundry      │  │     server-1      │  │     server-2      │
│                   │  │                   │  │                   │
│  Orchestrator     │  │      Agent        │  │      Agent        │
│  + Agent          │  │        │          │  │        │          │
│      │            │  │   ┌────┴────┐     │  │   ┌────┴────┐     │
│ ┌────┴────┐       │  │   │ electrs │     │  │   │   lnd   │     │
│ │ bitcoin │       │  │   │ mempool │     │  │   │   rtl   │     │
│ └─────────┘       │  │   └─────────┘     │  │   └─────────┘     │
└───────────────────┘  └───────────────────┘  └───────────────────┘
```

### Foundry as Control Only

Orchestrator doesn't run apps:

```
┌───────────────────┐  ┌───────────────────┐  ┌───────────────────┐
│      foundry      │  │     server-1      │  │     server-2      │
│                   │  │                   │  │                   │
│  Orchestrator     │  │      Agent        │  │      Agent        │
│  (no agent)       │  │        │          │  │        │          │
│                   │  │   ┌────┴────┐     │  │   ┌────┴────┐     │
│                   │  │   │ bitcoin │     │  │   │ electrs │     │
│                   │  │   │ mempool │     │  │   └─────────┘     │
│                   │  │   └─────────┘     │  │                   │
└───────────────────┘  └───────────────────┘  └───────────────────┘
```

## Tech Stack

```
Orchestrator (foundry):
├── Runtime:    Node.js 20+
├── Language:   TypeScript
├── API:        Express.js
├── Realtime:   Socket.io
├── Database:   SQLite (better-sqlite3)
├── Secrets:    AES-256-GCM encryption
├── Proxy:      Caddy (dynamic config)
└── Templates:  Nunjucks

Agent (all servers):
├── Runtime:    Node.js 20+
├── Language:   TypeScript
├── Connection: Socket.io client
└── Runs as:    systemd service

Frontend:
├── Framework:  React 18+
├── Language:   TypeScript
├── Build:      Vite
├── State:      React Query + Zustand
├── UI:         Tailwind CSS + shadcn/ui
└── Realtime:   Socket.io client

Shared:
├── Types:      TypeScript interfaces
└── Validation: Zod schemas
```

## Project Structure

```
github.com/yourname/ownprem/
├── package.json                    # Monorepo root
├── tsconfig.base.json
├── CLAUDE.md                       # Claude Code instructions
│
├── packages/
│   └── shared/                     # Shared types
│       ├── package.json
│       └── src/
│           ├── types/
│           │   ├── server.ts
│           │   ├── app.ts
│           │   ├── deployment.ts
│           │   ├── service.ts
│           │   └── commands.ts
│           ├── schemas/
│           │   └── manifest.ts
│           └── index.ts
│
├── apps/
│   ├── orchestrator/               # Runs on foundry
│   │   ├── package.json
│   │   ├── tsconfig.json
│   │   └── src/
│   │       ├── index.ts
│   │       ├── config.ts
│   │       ├── api/
│   │       │   ├── index.ts
│   │       │   ├── routes/
│   │       │   │   ├── servers.ts
│   │       │   │   ├── apps.ts
│   │       │   │   └── system.ts
│   │       │   └── middleware/
│   │       │       ├── auth.ts
│   │       │       └── error.ts
│   │       ├── websocket/
│   │       │   ├── index.ts
│   │       │   └── agentHandler.ts
│   │       ├── services/
│   │       │   ├── serverManager.ts
│   │       │   ├── appRegistry.ts
│   │       │   ├── deployer.ts
│   │       │   ├── dependencyResolver.ts
│   │       │   ├── secretsManager.ts
│   │       │   ├── configRenderer.ts
│   │       │   ├── serviceRegistry.ts
│   │       │   └── proxyManager.ts
│   │       ├── proxy/
│   │       │   └── caddy.ts
│   │       └── db/
│   │           ├── index.ts
│   │           ├── schema.sql
│   │           └── migrations/
│   │
│   ├── agent/                      # Runs on all servers
│   │   ├── package.json
│   │   ├── tsconfig.json
│   │   └── src/
│   │       ├── index.ts
│   │       ├── connection.ts
│   │       ├── executor.ts
│   │       └── reporter.ts
│   │
│   └── ui/                         # Frontend
│       ├── package.json
│       ├── tsconfig.json
│       ├── vite.config.ts
│       └── src/
│           ├── main.tsx
│           ├── App.tsx
│           ├── api/
│           │   ├── client.ts
│           │   └── websocket.ts
│           ├── stores/
│           │   ├── servers.ts
│           │   └── apps.ts
│           ├── components/
│           │   ├── layout/
│           │   ├── servers/
│           │   └── apps/
│           └── pages/
│               ├── Dashboard.tsx
│               ├── Servers.tsx
│               ├── Apps.tsx
│               └── Settings.tsx
│
├── app-definitions/                # App manifests + scripts
│   ├── bitcoin/
│   │   ├── manifest.yaml
│   │   ├── install.sh
│   │   ├── configure.sh
│   │   ├── uninstall.sh
│   │   └── templates/
│   │       └── bitcoin.conf.njk
│   ├── electrs/
│   │   ├── manifest.yaml
│   │   ├── install.sh
│   │   ├── configure.sh
│   │   └── templates/
│   │       └── electrs.toml.njk
│   ├── mempool/
│   │   ├── manifest.yaml
│   │   ├── install.sh
│   │   ├── configure.sh
│   │   └── templates/
│   │       └── mempool-config.json.njk
│   └── lnd/
│       └── ...
│
└── scripts/
    ├── install-foundry.sh          # Install orchestrator + agent
    └── install-server.sh           # Install agent only
```

## Shared Types

```typescript
// packages/shared/src/types/server.ts

export interface Server {
  id: string;                       // 'foundry', 'server-1', etc.
  name: string;
  host: string | null;              // null for foundry (local)
  isFoundry: boolean;
  agentStatus: 'online' | 'offline' | 'error';
  authToken: string | null;         // null for foundry
  metrics?: ServerMetrics;
  lastSeen: Date | null;
  createdAt: Date;
}

export interface ServerMetrics {
  cpuPercent: number;
  memoryUsed: number;
  memoryTotal: number;
  diskUsed: number;
  diskTotal: number;
  loadAverage: [number, number, number];
}
```

```typescript
// packages/shared/src/types/app.ts

export interface AppManifest {
  name: string;                     // 'bitcoin', 'electrs', etc.
  displayName: string;              // 'Bitcoin Knots'
  description: string;
  version: string;
  category: 'bitcoin' | 'lightning' | 'indexer' | 'explorer' | 'utility';
  
  source: AppSource;
  
  provides?: ServiceDefinition[];
  requires?: ServiceRequirement[];
  
  tor?: TorService[];
  
  webui?: WebUI;
  
  configSchema: ConfigField[];
  
  resources?: {
    minMemory?: string;
    minDisk?: string;
  };
}

export interface AppSource {
  type: 'binary' | 'git' | 'apt';
  githubRepo?: string;
  downloadUrl?: string;
  checksumUrl?: string;
  gitUrl?: string;
  tagPrefix?: string;
}

export interface ServiceDefinition {
  name: string;                     // 'bitcoin-rpc'
  port: number;
  protocol: 'tcp' | 'http' | 'zmq';
  credentials?: {
    type: 'rpc' | 'token' | 'password';
    fields: string[];               // ['username', 'password']
  };
}

export interface ServiceRequirement {
  service: string;                  // 'bitcoin-rpc'
  optional?: boolean;
  locality: 'same-server' | 'any-server' | 'prefer-same-server';
  injectAs: {
    host?: string;
    port?: string;
    credentials?: Record<string, string>;
  };
}

export interface TorService {
  name: string;
  virtualPort: number;
  targetPort: number;
}

export interface WebUI {
  enabled: boolean;
  port: number;
  basePath: string;                 // '/apps/mempool'
}

export interface ConfigField {
  name: string;
  type: 'string' | 'number' | 'boolean' | 'select' | 'password';
  label: string;
  description?: string;
  default?: any;
  options?: string[];
  required?: boolean;
  generated?: boolean;
  secret?: boolean;
  inheritFrom?: string;
}
```

```typescript
// packages/shared/src/types/deployment.ts

export interface Deployment {
  id: string;
  serverId: string;
  appName: string;
  version: string;
  config: Record<string, any>;
  status: DeploymentStatus;
  statusMessage?: string;
  torAddresses?: Record<string, string>;
  installedAt: Date;
  updatedAt: Date;
}

export type DeploymentStatus =
  | 'pending'
  | 'installing'
  | 'configuring'
  | 'running'
  | 'stopped'
  | 'error'
  | 'updating'
  | 'uninstalling';
```

```typescript
// packages/shared/src/types/commands.ts

export interface AgentCommand {
  id: string;
  action: 'install' | 'configure' | 'start' | 'stop' | 'restart' | 'uninstall';
  appName: string;
  payload?: {
    version?: string;
    files?: ConfigFile[];
    env?: Record<string, string>;
  };
}

export interface ConfigFile {
  path: string;
  content: string;
  mode?: string;
  owner?: string;
}

export interface CommandResult {
  commandId: string;
  status: 'success' | 'error';
  message?: string;
  duration?: number;
}

export interface AgentStatusReport {
  serverId: string;
  timestamp: Date;
  metrics: ServerMetrics;
  apps: AppStatus[];
}

export interface AppStatus {
  name: string;
  status: 'running' | 'stopped' | 'error' | 'not-installed';
  version?: string;
  syncProgress?: number;
  blockHeight?: number;
  torAddresses?: Record<string, string>;
}
```

## Database Schema

```sql
-- Servers (all machines including foundry)
CREATE TABLE servers (
    id TEXT PRIMARY KEY,            -- 'foundry', 'server-1', etc.
    name TEXT NOT NULL UNIQUE,
    host TEXT,                      -- NULL for foundry
    is_foundry BOOLEAN DEFAULT FALSE,
    agent_status TEXT DEFAULT 'offline',
    auth_token TEXT,                -- NULL for foundry
    metrics JSON,
    last_seen TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- App registry (loaded from app-definitions/)
CREATE TABLE app_registry (
    name TEXT PRIMARY KEY,
    manifest JSON NOT NULL,
    loaded_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Deployments (apps installed on servers)
CREATE TABLE deployments (
    id TEXT PRIMARY KEY,
    server_id TEXT NOT NULL REFERENCES servers(id) ON DELETE CASCADE,
    app_name TEXT NOT NULL REFERENCES app_registry(name),
    version TEXT NOT NULL,
    config JSON NOT NULL,
    status TEXT DEFAULT 'pending',
    status_message TEXT,
    tor_addresses JSON,
    installed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    UNIQUE(server_id, app_name)
);

-- Secrets (encrypted)
CREATE TABLE secrets (
    deployment_id TEXT PRIMARY KEY REFERENCES deployments(id) ON DELETE CASCADE,
    data TEXT NOT NULL,             -- Encrypted JSON
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Service registry
CREATE TABLE services (
    id TEXT PRIMARY KEY,
    deployment_id TEXT NOT NULL REFERENCES deployments(id) ON DELETE CASCADE,
    service_name TEXT NOT NULL,
    server_id TEXT NOT NULL REFERENCES servers(id),
    host TEXT NOT NULL,
    port INTEGER NOT NULL,
    tor_address TEXT,
    status TEXT DEFAULT 'available',
    
    UNIQUE(deployment_id, service_name)
);

CREATE INDEX idx_services_name ON services(service_name);

-- Proxy routes (for web UIs)
CREATE TABLE proxy_routes (
    id TEXT PRIMARY KEY,
    deployment_id TEXT NOT NULL REFERENCES deployments(id) ON DELETE CASCADE,
    path TEXT NOT NULL UNIQUE,      -- '/apps/mempool'
    upstream TEXT NOT NULL,         -- 'http://10.0.0.11:3006'
    active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Command log
CREATE TABLE command_log (
    id TEXT PRIMARY KEY,
    server_id TEXT NOT NULL,
    deployment_id TEXT,
    action TEXT NOT NULL,
    payload JSON,
    status TEXT,
    result_message TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    completed_at TIMESTAMP
);

-- Initialize foundry on first run
INSERT INTO servers (id, name, is_foundry, agent_status)
VALUES ('foundry', 'foundry', TRUE, 'offline');
```

## API Endpoints

```
REST API:

Servers:
  GET    /api/servers               List all servers
  POST   /api/servers               Add server (returns bootstrap command)
  GET    /api/servers/:id           Get server details
  PUT    /api/servers/:id           Update server
  DELETE /api/servers/:id           Remove server

Apps (registry):
  GET    /api/apps                  List available apps
  GET    /api/apps/:name            Get app manifest
  GET    /api/apps/:name/versions   Get available versions

Deployments:
  GET    /api/deployments           List all deployments
  POST   /api/deployments           Install app
  GET    /api/deployments/:id       Get deployment details
  PUT    /api/deployments/:id       Update config
  POST   /api/deployments/:id/start Start app
  POST   /api/deployments/:id/stop  Stop app
  DELETE /api/deployments/:id       Uninstall app

Services:
  GET    /api/services              List available services
  GET    /api/services/:name        Get service providers

System:
  GET    /api/system/status         Overall status
  GET    /api/system/proxy-routes   Current proxy configuration

WebSocket Events:

Server → Client:
  server:status       Server metrics update
  server:connected    Server came online
  server:disconnected Server went offline
  deployment:status   Deployment status change
  command:result      Command completed

Client → Server:
  subscribe:server    Subscribe to server updates
  subscribe:logs      Subscribe to log stream
```

## Reverse Proxy

### URL Structure

```
https://foundry.local/                  → Foundry UI
https://foundry.local/api/              → Foundry API
https://foundry.local/apps/mempool/     → Mempool (proxied to server-1:3006)
https://foundry.local/apps/rtl/         → RTL (proxied to server-2:3000)
https://foundry.local/apps/thunderhub/  → ThunderHub (proxied to server-2:3001)
```

### Proxy Manager

```typescript
// apps/orchestrator/src/services/proxyManager.ts

export class ProxyManager {
  constructor(private db: Database) {}
  
  async updateRoutes() {
    const deployments = await this.db.query(`
      SELECT 
        d.id,
        d.server_id,
        s.host,
        ar.manifest
      FROM deployments d
      JOIN servers s ON d.server_id = s.id
      JOIN app_registry ar ON d.app_name = ar.name
      WHERE d.status = 'running'
      AND JSON_EXTRACT(ar.manifest, '$.webui.enabled') = true
    `);
    
    const routes = deployments.map(d => {
      const webui = d.manifest.webui;
      const host = d.host || '127.0.0.1';
      return {
        path: webui.basePath,
        upstream: `http://${host}:${webui.port}`
      };
    });
    
    await this.writeCaddyConfig(routes);
    await this.reloadCaddy();
  }
  
  private async writeCaddyConfig(routes: Route[]) {
    const config = `
{
  auto_https off
}

:3000 {
  # Foundry UI
  handle / {
    root * /opt/ownprem/ui/dist
    file_server
    try_files {path} /index.html
  }
  
  # Foundry API
  handle /api/* {
    reverse_proxy localhost:3001
  }
  
  # WebSocket
  handle /socket.io/* {
    reverse_proxy localhost:3001
  }
  
  # App Web UIs
${routes.map(r => `
  handle ${r.path}/* {
    uri strip_prefix ${r.path}
    reverse_proxy ${r.upstream}
  }
`).join('\n')}
}
`;
    await writeFile('/etc/caddy/Caddyfile', config);
  }
}
```

### Authentication Middleware

All requests to `/apps/*` require valid foundry session:

```typescript
// apps/orchestrator/src/api/middleware/auth.ts

export function requireAuth(req: Request, res: Response, next: NextFunction) {
  const session = getSession(req);
  
  if (!session || !session.valid) {
    if (req.path.startsWith('/apps/')) {
      return res.redirect('/login?redirect=' + encodeURIComponent(req.path));
    }
    return res.status(401).json({ error: 'Unauthorized' });
  }
  
  next();
}
```

## Agent Implementation

```typescript
// apps/agent/src/index.ts

import { io, Socket } from 'socket.io-client';
import { AgentCommand, AgentStatusReport } from '@ownprem/shared';
import { Executor } from './executor';
import { Reporter } from './reporter';

class Agent {
  private socket: Socket;
  private executor: Executor;
  private reporter: Reporter;
  
  constructor(
    private serverId: string,
    private foundryUrl: string,
    private authToken: string | null
  ) {
    this.executor = new Executor();
    this.reporter = new Reporter(serverId);
  }
  
  async start() {
    this.connect();
    setInterval(() => this.reportStatus(), 10000);
  }
  
  private connect() {
    this.socket = io(this.foundryUrl, {
      auth: {
        serverId: this.serverId,
        token: this.authToken
      },
      reconnection: true,
      reconnectionDelay: 5000
    });
    
    this.socket.on('connect', () => {
      console.log(`Connected to foundry as ${this.serverId}`);
      this.reportStatus();
    });
    
    this.socket.on('command', async (cmd: AgentCommand) => {
      await this.handleCommand(cmd);
    });
  }
  
  private async handleCommand(cmd: AgentCommand) {
    console.log(`[${cmd.id}] ${cmd.action} ${cmd.appName}`);
    const start = Date.now();
    
    try {
      switch (cmd.action) {
        case 'install':
          await this.executor.install(cmd.appName, cmd.payload!);
          break;
        case 'configure':
          await this.executor.configure(cmd.appName, cmd.payload!.files!);
          break;
        case 'start':
          await this.executor.systemctl('start', cmd.appName);
          break;
        case 'stop':
          await this.executor.systemctl('stop', cmd.appName);
          break;
        case 'restart':
          await this.executor.systemctl('restart', cmd.appName);
          break;
        case 'uninstall':
          await this.executor.uninstall(cmd.appName);
          break;
      }
      
      this.socket.emit('command:result', {
        commandId: cmd.id,
        status: 'success',
        duration: Date.now() - start
      });
    } catch (err) {
      this.socket.emit('command:result', {
        commandId: cmd.id,
        status: 'error',
        message: err.message,
        duration: Date.now() - start
      });
    }
    
    await this.reportStatus();
  }
  
  private async reportStatus() {
    const status: AgentStatusReport = {
      serverId: this.serverId,
      timestamp: new Date(),
      metrics: await this.reporter.getMetrics(),
      apps: await this.reporter.getAppStatuses()
    };
    
    this.socket.emit('status', status);
  }
}

// Entry point
const agent = new Agent(
  process.env.SERVER_ID!,
  process.env.FOUNDRY_URL!,
  process.env.AUTH_TOKEN || null
);
agent.start();
```

```typescript
// apps/agent/src/executor.ts

import { execSync } from 'child_process';
import { writeFileSync, mkdirSync } from 'fs';
import { dirname } from 'path';
import { CommandPayload, ConfigFile } from '@ownprem/shared';

export class Executor {
  private appsDir = '/opt/ownprem/apps';
  
  async install(appName: string, payload: CommandPayload) {
    const appDir = `${this.appsDir}/${appName}`;
    mkdirSync(appDir, { recursive: true });
    
    await this.writeFiles(payload.files || []);
    
    this.runScript(`${appDir}/install.sh`, {
      ...process.env,
      ...payload.env,
      APP_NAME: appName,
      APP_VERSION: payload.version || ''
    });
  }
  
  async configure(appName: string, files: ConfigFile[]) {
    await this.writeFiles(files);
    
    const appDir = `${this.appsDir}/${appName}`;
    this.runScript(`${appDir}/configure.sh`, { APP_NAME: appName });
  }
  
  async uninstall(appName: string) {
    await this.systemctl('stop', appName).catch(() => {});
    
    const appDir = `${this.appsDir}/${appName}`;
    this.runScript(`${appDir}/uninstall.sh`, { APP_NAME: appName });
  }
  
  async systemctl(action: string, service: string) {
    execSync(`systemctl ${action} ${service}`, { stdio: 'inherit' });
  }
  
  private async writeFiles(files: ConfigFile[]) {
    for (const file of files) {
      mkdirSync(dirname(file.path), { recursive: true });
      writeFileSync(file.path, file.content, {
        mode: parseInt(file.mode || '0644', 8)
      });
      if (file.owner) {
        execSync(`chown ${file.owner} ${file.path}`);
      }
    }
  }
  
  private runScript(script: string, env: Record<string, string>) {
    execSync(`bash ${script}`, { stdio: 'inherit', env: env as any });
  }
}
```

## Dependency Resolution

```typescript
// apps/orchestrator/src/services/dependencyResolver.ts

export class DependencyResolver {
  constructor(
    private db: Database,
    private secrets: SecretsManager
  ) {}
  
  async validate(appName: string, targetServerId: string): Promise<ValidationResult> {
    const manifest = await this.getManifest(appName);
    const errors: string[] = [];
    const warnings: string[] = [];
    
    for (const req of manifest.requires || []) {
      const provider = await this.findProvider(req.service);
      
      if (!provider) {
        if (req.optional) {
          warnings.push(`Optional service '${req.service}' not available`);
        } else {
          errors.push(`Required service '${req.service}' not found`);
        }
        continue;
      }
      
      const sameServer = provider.serverId === targetServerId;
      
      if (req.locality === 'same-server' && !sameServer) {
        errors.push(`${req.service} must be on same server`);
      }
      
      if (req.locality === 'prefer-same-server' && !sameServer) {
        warnings.push(`${req.service} on different server may have higher latency`);
      }
    }
    
    return { valid: errors.length === 0, errors, warnings };
  }
  
  async resolve(
    manifest: AppManifest,
    targetServerId: string,
    userConfig: Record<string, any>
  ): Promise<Record<string, any>> {
    const config = { ...userConfig };
    
    for (const req of manifest.requires || []) {
      const connection = await this.getConnection(req.service, targetServerId);
      
      if (connection) {
        if (req.injectAs.host) config[req.injectAs.host] = connection.host;
        if (req.injectAs.port) config[req.injectAs.port] = connection.port;
        
        if (req.injectAs.credentials && connection.credentials) {
          for (const [from, to] of Object.entries(req.injectAs.credentials)) {
            config[to] = connection.credentials[from];
          }
        }
      }
    }
    
    // Handle inheritFrom
    for (const field of manifest.configSchema) {
      if (field.inheritFrom && config[field.name] === undefined) {
        const [depApp, depField] = field.inheritFrom.split('.');
        const depConfig = await this.getDeploymentConfig(depApp);
        if (depConfig) config[field.name] = depConfig[depField];
      }
    }
    
    return config;
  }
  
  private async getConnection(serviceName: string, consumerServerId: string) {
    const service = await this.db.get(`
      SELECT s.*, srv.host 
      FROM services s
      JOIN servers srv ON s.server_id = srv.id
      WHERE s.service_name = ? AND s.status = 'available'
    `, [serviceName]);
    
    if (!service) return null;
    
    const sameServer = service.server_id === consumerServerId;
    const host = sameServer ? '127.0.0.1' : service.host;
    
    const creds = await this.secrets.getServiceCredentials(service.deployment_id);
    
    return { host, port: service.port, credentials: creds };
  }
}
```

## App Manifest Examples

### Bitcoin

```yaml
# app-definitions/bitcoin/manifest.yaml

name: bitcoin
displayName: Bitcoin Knots
description: Full Bitcoin node with enhanced features
version: 29.2.knots20251110
category: bitcoin

source:
  type: binary
  githubRepo: bitcoinknots/bitcoin
  downloadUrl: "https://bitcoinknots.org/files/29.x/${version}/bitcoin-${version}-${arch}.tar.gz"
  checksumUrl: "https://bitcoinknots.org/files/29.x/${version}/SHA256SUMS"

provides:
  - name: bitcoin-rpc
    port: 8332
    protocol: http
    credentials:
      type: rpc
      fields: [rpcuser, rpcpassword]
  - name: bitcoin-p2p
    port: 8333
    protocol: tcp
  - name: bitcoin-zmq-block
    port: 28332
    protocol: zmq
  - name: bitcoin-zmq-tx
    port: 28333
    protocol: zmq

tor:
  - name: bitcoin-p2p
    virtualPort: 8333
    targetPort: 8333
  - name: bitcoin-rpc
    virtualPort: 8332
    targetPort: 8332

configSchema:
  - name: network
    type: select
    label: Network
    options: [mainnet, testnet, signet]
    default: mainnet
  - name: txindex
    type: boolean
    label: Transaction Index
    default: true
  - name: prune
    type: number
    label: Prune (MB)
    description: "0 = no pruning"
    default: 0
  - name: rpcuser
    type: string
    generated: true
    secret: true
  - name: rpcpassword
    type: password
    generated: true
    secret: true

resources:
  minDisk: 700GB
  minMemory: 2GB
```

### Electrs

```yaml
# app-definitions/electrs/manifest.yaml

name: electrs
displayName: Electrs
description: Efficient Electrum Server in Rust
version: 0.11.0
category: indexer

source:
  type: git
  githubRepo: romanz/electrs
  gitUrl: https://github.com/romanz/electrs.git
  tagPrefix: v

requires:
  - service: bitcoin-rpc
    locality: prefer-same-server
    injectAs:
      host: daemon_rpc_host
      port: daemon_rpc_port
      credentials:
        rpcuser: daemon_rpc_user
        rpcpassword: daemon_rpc_pass

provides:
  - name: electrs-rpc
    port: 50001
    protocol: tcp

tor:
  - name: electrs
    virtualPort: 50001
    targetPort: 50001

configSchema:
  - name: network
    type: string
    inheritFrom: bitcoin.network
  - name: log_filters
    type: select
    label: Log Level
    options: [ERROR, WARN, INFO, DEBUG]
    default: INFO

resources:
  minDisk: 50GB
  minMemory: 4GB
```

### Mempool

```yaml
# app-definitions/mempool/manifest.yaml

name: mempool
displayName: Mempool Explorer
description: Bitcoin blockchain explorer and mempool visualizer
version: 3.2.1
category: explorer

source:
  type: git
  githubRepo: mempool/mempool
  gitUrl: https://github.com/mempool/mempool.git
  tagPrefix: v

requires:
  - service: bitcoin-rpc
    locality: any-server
    injectAs:
      host: CORE_RPC_HOST
      port: CORE_RPC_PORT
      credentials:
        rpcuser: CORE_RPC_USERNAME
        rpcpassword: CORE_RPC_PASSWORD
  - service: electrs-rpc
    locality: any-server
    injectAs:
      host: ELECTRUM_HOST
      port: ELECTRUM_PORT

provides:
  - name: mempool-api
    port: 8999
    protocol: http

webui:
  enabled: true
  port: 3006
  basePath: /apps/mempool

tor:
  - name: mempool
    virtualPort: 443
    targetPort: 3006

configSchema:
  - name: network
    type: string
    inheritFrom: bitcoin.network
  - name: db_password
    type: password
    generated: true
    secret: true

resources:
  minDisk: 10GB
  minMemory: 2GB
```

## GUI Wireframes

### Dashboard

```
┌─────────────────────────────────────────────────────────────────────┐
│  Ownprem                                       admin ▼    ⚙️    │
├────────────┬────────────────────────────────────────────────────────┤
│            │                                                        │
│  Dashboard │  SERVERS                                               │
│  Servers   │  ┌─────────────────────────────────────────────────┐  │
│  Apps      │  │ ● foundry      local    agent ✓    1 app        │  │
│  Settings  │  │ ● server-1     online   agent ✓    2 apps       │  │
│            │  │ ● server-2     online   agent ✓    2 apps       │  │
│            │  │ ○ server-3     offline  agent ✗    -            │  │
│            │  └─────────────────────────────────────────────────┘  │
│            │                                                        │
│            │  APPS WITH WEB UI                                      │
│            │  ┌──────────┐  ┌──────────┐  ┌──────────┐            │
│            │  │ ░░░░░░░░ │  │ ░░░░░░░░ │  │ ░░░░░░░░ │            │
│            │  │ Mempool  │  │   RTL    │  │ Thunder  │            │
│            │  │ server-1 │  │ server-2 │  │   Hub    │            │
│            │  │  [Open]  │  │  [Open]  │  │  [Open]  │            │
│            │  └──────────┘  └──────────┘  └──────────┘            │
│            │                                                        │
│            │  ALL DEPLOYMENTS                                       │
│            │  ┌─────────────────────────────────────────────────┐  │
│            │  │ App       Server     Status     Version         │  │
│            │  │ bitcoin   foundry    ● Synced   29.2            │  │
│            │  │ electrs   server-1   ● Indexed  0.11.0          │  │
│            │  │ mempool   server-1   ● Running  3.2.1           │  │
│            │  │ lnd       server-2   ● Running  0.18.0          │  │
│            │  │ rtl       server-2   ● Running  0.15.0          │  │
│            │  └─────────────────────────────────────────────────┘  │
└────────────┴────────────────────────────────────────────────────────┘
```

### Install App

```
┌─────────────────────────────────────────────────────────────────────┐
│  Install Electrs                                              [X]  │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  Version:  [0.11.0 (latest) ▼]                                     │
│  Server:   [server-1 ▼]                                            │
│                                                                     │
│  DEPENDENCIES                                                       │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │ ✓ bitcoin-rpc                                               │   │
│  │   Provided by: bitcoin on foundry (127.0.0.1:8332)          │   │
│  │   ⚠ Different server - connection via LAN                   │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
│  CONFIGURATION                                                      │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │ Network:    [mainnet]     (from bitcoin)                    │   │
│  │ Log Level:  [INFO ▼]                                        │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
│  TOR                                                                │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │ [✓] electrs (50001)                                         │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
│                                      [Cancel]    [Install]         │
└─────────────────────────────────────────────────────────────────────┘
```

## Install Scripts

### Foundry (orchestrator + agent)

```bash
#!/bin/bash
# scripts/install-foundry.sh

set -e

echo "Installing Ownprem..."

# Install Node.js
curl -fsSL https://deb.nodesource.com/setup_20.x | bash -
apt-get install -y nodejs

# Install Caddy
apt-get install -y debian-keyring debian-archive-keyring apt-transport-https curl
curl -1sLf 'https://dl.cloudsmith.io/public/caddy/stable/gpg.key' | gpg --dearmor -o /usr/share/keyrings/caddy-stable-archive-keyring.gpg
curl -1sLf 'https://dl.cloudsmith.io/public/caddy/stable/debian.deb.txt' | tee /etc/apt/sources.list.d/caddy-stable.list
apt-get update
apt-get install -y caddy

# Create directories
mkdir -p /opt/ownprem/{orchestrator,agent,ui,apps}
mkdir -p /var/lib/ownprem
mkdir -p /etc/ownprem

# Clone/pull repo
cd /opt/ownprem
git clone https://github.com/yourname/ownprem.git repo || (cd repo && git pull)

# Build
cd repo
npm install
npm run build

# Copy built files
cp -r apps/orchestrator/dist/* /opt/ownprem/orchestrator/
cp -r apps/agent/dist/* /opt/ownprem/agent/
cp -r apps/ui/dist/* /opt/ownprem/ui/

# Generate secrets key
SECRETS_KEY=$(openssl rand -hex 32)

# Config
cat > /etc/ownprem/foundry.env << EOF
NODE_ENV=production
PORT=3001
DATABASE_PATH=/var/lib/ownprem/db.sqlite
SECRETS_KEY=${SECRETS_KEY}
EOF

cat > /etc/ownprem/agent.env << EOF
SERVER_ID=foundry
FOUNDRY_URL=http://localhost:3001
EOF

# Systemd services
cat > /etc/systemd/system/ownprem-orchestrator.service << 'EOF'
[Unit]
Description=Ownprem Orchestrator
After=network.target

[Service]
Type=simple
EnvironmentFile=/etc/ownprem/foundry.env
WorkingDirectory=/opt/ownprem/orchestrator
ExecStart=/usr/bin/node index.js
Restart=always
RestartSec=10

[Install]
WantedBy=multi-user.target
EOF

cat > /etc/systemd/system/ownprem-agent.service << 'EOF'
[Unit]
Description=Ownprem Agent
After=network.target ownprem-orchestrator.service

[Service]
Type=simple
EnvironmentFile=/etc/ownprem/agent.env
WorkingDirectory=/opt/ownprem/agent
ExecStart=/usr/bin/node index.js
Restart=always
RestartSec=10

[Install]
WantedBy=multi-user.target
EOF

systemctl daemon-reload
systemctl enable ownprem-orchestrator ownprem-agent caddy
systemctl start ownprem-orchestrator ownprem-agent caddy

IP=$(hostname -I | awk '{print $1}')
echo ""
echo "Ownprem installed!"
echo "Access at: http://${IP}:3000"
```

### Server (agent only)

```bash
#!/bin/bash
# scripts/install-server.sh
# Usage: ./install-server.sh --foundry https://foundry.local:3000 --token <token>

set -e

FOUNDRY_URL=""
AUTH_TOKEN=""
SERVER_ID=""

while [[ $# -gt 0 ]]; do
  case $1 in
    --foundry) FOUNDRY_URL="$2"; shift 2 ;;
    --token) AUTH_TOKEN="$2"; shift 2 ;;
    --id) SERVER_ID="$2"; shift 2 ;;
    *) shift ;;
  esac
done

if [[ -z "$FOUNDRY_URL" || -z "$AUTH_TOKEN" ]]; then
  echo "Usage: $0 --foundry <url> --token <token> [--id <server-id>]"
  exit 1
fi

SERVER_ID="${SERVER_ID:-server-$(hostname -s)}"

echo "Installing Ownprem Agent..."

# Install Node.js
curl -fsSL https://deb.nodesource.com/setup_20.x | bash -
apt-get install -y nodejs

# Create directories
mkdir -p /opt/ownprem/{agent,apps}
mkdir -p /etc/ownprem

# Download agent from foundry
curl -sSL "${FOUNDRY_URL}/agent/bundle.tar.gz" | tar -xz -C /opt/ownprem/agent

# Config
cat > /etc/ownprem/agent.env << EOF
SERVER_ID=${SERVER_ID}
FOUNDRY_URL=${FOUNDRY_URL}
AUTH_TOKEN=${AUTH_TOKEN}
EOF

chmod 600 /etc/ownprem/agent.env

# Systemd service
cat > /etc/systemd/system/ownprem-agent.service << 'EOF'
[Unit]
Description=Ownprem Agent
After=network.target

[Service]
Type=simple
EnvironmentFile=/etc/ownprem/agent.env
WorkingDirectory=/opt/ownprem/agent
ExecStart=/usr/bin/node index.js
Restart=always
RestartSec=10

[Install]
WantedBy=multi-user.target
EOF

systemctl daemon-reload
systemctl enable ownprem-agent
systemctl start ownprem-agent

echo ""
echo "Agent installed and connected to foundry as: ${SERVER_ID}"
```

## CLAUDE.md

```markdown
# Ownprem - Development Guide

## Overview
Sovereign Bitcoin infrastructure platform. Foundry (orchestrator) manages 
servers running Bitcoin apps. Single entry point with reverse proxy to all app UIs.

## Architecture
- **Foundry**: Orchestrator - one per deployment
- **Server**: App server - runs agent + apps (foundry, server-1, server-2...)
- **App**: Bitcoin services (bitcoin, electrs, mempool, lnd...)

Orchestrator ALWAYS talks to agent, even on localhost. Same code path everywhere.

## Key Directories
- `apps/orchestrator/` - API, WebSocket, database, secrets, proxy
- `apps/agent/` - Executor, reporter (runs on all servers)
- `apps/ui/` - React frontend
- `packages/shared/` - TypeScript types
- `app-definitions/` - App manifests + install scripts

## Commands
```bash
npm run dev              # Full stack development
npm run dev:orchestrator # Orchestrator only
npm run dev:agent        # Agent only  
npm run dev:ui           # Frontend only
npm run build            # Production build
npm run test             # Run tests
npm run typecheck        # TypeScript check
```

## Test VMs
- foundry: 10.100.6.60 (orchestrator + agent)
- server-1: 10.100.6.61 (agent only)

## Database
SQLite at /var/lib/ownprem/db.sqlite
Schema in apps/orchestrator/src/db/schema.sql

## Key Flows

### Install App
1. UI calls POST /api/deployments
2. Orchestrator validates dependencies
3. Orchestrator generates credentials
4. Orchestrator resolves config (user + deps + secrets)
5. Orchestrator renders templates
6. Orchestrator sends 'install' command via WebSocket
7. Agent writes files, runs scripts
8. Agent reports status
9. Orchestrator updates proxy routes (if app has webui)

### Proxy
Caddy on foundry. Config rebuilt when apps start/stop.
- / → UI
- /api/* → Orchestrator API
- /apps/mempool/* → server-1:3006
- /apps/rtl/* → server-2:3000

## Current Phase
Phase 1: Foundation
- [ ] Shared types
- [ ] Database schema
- [ ] Basic API (servers CRUD)
- [ ] Agent connection
```

## Implementation Order

### Phase 1: Foundation (Local Ubuntu)

All development on local Ubuntu machine, all-in-one mode.

1. **Shared types package**
   - TypeScript interfaces
   - Zod validation schemas

2. **Database + API skeleton**
   - SQLite schema
   - Express server
   - Basic server CRUD

3. **Agent communication**
   - WebSocket setup (Socket.io)
   - Agent connection handshake
   - Command/response flow

4. **Mock app**
   - Simple test app (no real Bitcoin)
   - Test full install flow locally

### Phase 2: Core Features (Local Ubuntu)

5. **App management**
   - App registry (load manifests)
   - Config renderer (Nunjucks)
   - Basic deployer

6. **Secrets**
   - Generation
   - AES-256-GCM encryption
   - Storage + retrieval

7. **Dependencies**
   - Dependency resolver
   - Service registry
   - Credential injection

8. **Proxy**
   - Caddy config generator
   - Dynamic route updates

### Phase 3: Frontend (Local Ubuntu)

9. **React UI**
   - Vite setup
   - Dashboard
   - Server/app views
   - Install flow

10. **Real-time updates**
    - WebSocket integration
    - Status updates
    - Log streaming

### Phase 4: Multi-Node (Debian VMs)

11. **Deploy to Debian VMs**
    - foundry VM (orchestrator + agent)
    - server-1 VM (agent only)
    - Test cross-server communication

12. **Install scripts**
    - install-foundry.sh
    - install-server.sh
    - Bootstrap flow

### Phase 5: Real Apps

13. **Bitcoin (regtest first)**
    - Test with regtest (instant blocks)
    - Then signet/testnet
    - Finally mainnet

14. **Electrs, Mempool, etc.**
    - Add real app definitions
    - Test dependency chain

### Phase 6: Polish

15. **Production hardening**
    - Tor integration
    - TLS/certificates
    - Auth improvements
    - Error recovery
    - Updates/upgrades


## Mock App for Testing

Use mock apps during development to test the platform without real Bitcoin:

```yaml
# app-definitions/mock-app/manifest.yaml

name: mock-app
displayName: Mock App  
description: Simple test app for platform development
version: 1.0.0
category: utility

provides:
  - name: mock-service
    port: 9999
    protocol: http

webui:
  enabled: true
  port: 9999
  basePath: /apps/mock-app

configSchema:
  - name: message
    type: string
    label: Welcome Message
    default: "Hello from Mock App"
```

```bash
# app-definitions/mock-app/install.sh
#!/bin/bash
set -e

APP_DIR="/opt/ownprem/apps/mock-app"
mkdir -p "$APP_DIR"

cat > "$APP_DIR/server.js" << 'EOF'
const http = require('http');
const msg = process.env.MESSAGE || 'Mock App Running';

const server = http.createServer((req, res) => {
  res.setHeader('Content-Type', 'text/html');
  res.end(`
    <!DOCTYPE html>
    <html>
    <head><title>Mock App</title></head>
    <body>
      <h1>${msg}</h1>
      <p>Mock app is running successfully!</p>
      <p>Server: ${process.env.SERVER_ID || 'unknown'}</p>
    </body>
    </html>
  `);
});

server.listen(9999, () => {
  console.log('Mock app listening on port 9999');
});
EOF

# Create systemd service
cat > /etc/systemd/system/mock-app.service << EOF
[Unit]
Description=Mock App
After=network.target

[Service]
Type=simple
Environment=MESSAGE=${MESSAGE:-Hello from Mock App}
ExecStart=/usr/bin/node ${APP_DIR}/server.js
Restart=always

[Install]
WantedBy=multi-user.target
EOF

systemctl daemon-reload
```

```bash
# app-definitions/mock-app/configure.sh
#!/bin/bash
systemctl restart mock-app
```

```bash
# app-definitions/mock-app/uninstall.sh
#!/bin/bash
systemctl stop mock-app || true
systemctl disable mock-app || true
rm -f /etc/systemd/system/mock-app.service
rm -rf /opt/ownprem/apps/mock-app
systemctl daemon-reload
```

## Mock Dependency App

Test dependency resolution with a second mock app:

```yaml
# app-definitions/mock-dependent/manifest.yaml

name: mock-dependent
displayName: Mock Dependent App
version: 1.0.0
category: utility

requires:
  - service: mock-service
    locality: any-server
    injectAs:
      host: UPSTREAM_HOST
      port: UPSTREAM_PORT

provides:
  - name: mock-dependent-service
    port: 9998
    protocol: http

webui:
  enabled: true
  port: 9998
  basePath: /apps/mock-dependent

configSchema:
  - name: UPSTREAM_HOST
    type: string
    label: Upstream Host
  - name: UPSTREAM_PORT
    type: number
    label: Upstream Port
```

This lets you test the full dependency chain without real Bitcoin.
